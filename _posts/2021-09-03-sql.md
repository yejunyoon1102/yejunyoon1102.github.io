---
layout: post
title: "데이터 분석: SQL 기초"
date: 2024-09-03
categories: [Data Analysis, SQL]
---
### 데이터 모델의 이해

데이터베이스의 모델링 : 현실 세계를 단순화하여 표현하는 기법

**모델링의 특징**

- 추상화 : 아이디어나 개념을 간략하게 표현하는 과정
- 단순화 : 단순하고 쉽게 표현
- 명확화 : 불분명함을 제거하고 명확하게 해석

**모델링의 세 가지 관점**

- 데이터 관점 : 데이터적 관점 모델링
- 프로세스 관점 : 프로세스적(업무적) 관점 모델링
- 데이터와 프로세스의 상관 관점 : 데이터 & 업무적 관점 모델링

**데이터 모델링 시 유의사항**

- 중복 : 같은 데이터가 여러 엔티티에 중복되는 현상 주의
- 비유연성 : 너무 자주 바뀌면 좀 그러니까 데이터 모델과 프로세스를 분리하여 유연성을 높임
- 비일관성 : 데이터간의 연관관계에 대해 명확히 정의해야

**데이터 모델링의 3가지 요소**

- 대상(Entity) : 업무가 관리하고자 하는 객체    ex) 학생
- 속성(Attribute) : 대상들이 갖는 속성    ex) 이름, 전화번호, 주소…
- 관계(Relationship) : 대상들 간의 관계    ex) 학생-선생님

**모델링의 3가지 단계**

1. 개념적 데이터 모델링 : 업무의 핵심 엔터티를 추출하는 단계, 관계를 표현하기 위해 ERD 작성, 추상화 레벨 가장 높음!
2. 논리적 데이터 모델링 : 데이터 정규화 수행, 동일한 논리적 모델을 사용하는 경우 쿼리도 재사용 가능, 데이터베이스 모델에 대한 key, 속성, 관계 등을 모두 표현
3. 물리적 데이터 모델링 : 실제 데이터베이스 구현, 추상화 수준은 가장 낮음

스키마 : 모든 객체들에 대한 정보(집합)

**3단계 스키마 구조**

- 외부 스키마 : 여러 사용자의 관점에서 사용자는 응용프로그램이 필요한 데이터를 정의
- 개념 스키마 : 통합된 관점으로 데이터베이스의 전체 논리적 구조를 정의
- 내부 스키마 : 물리적 관점에서 물리적인 저장 구조 정의(DB의 정의)
    
    **3단계 스키마 구조가 보장하는 독립성** : 한 쪽이 변경되더라도 다른 쪽에 영향을 주면 안됨
    
    - 논리적 독립성 : 개념 스키마가 변경되어도 외부 스키마는 영향받지 않는다
    - 물리적 독립성 : 내부 스키마가 변경되어도 외부/개념 스키마는 영향받지 않는다

ERD : 시스템에 엔터티들 간의 어떤 관계가 았는지 나타냄

ERD 작성 순서

1. 엔터티를 도출하고 그린다
2. 엔터티를 적절하게 배치한다
3. 엔터티 간의 관계를 설정한다
4. 관계명을 기입한다
5. 관계의 참여도를 기입한다
6. 관계의 필수/선택 여부를 기입한다

필수/선택적 관계와 ERD

1. IE 표기법
- 필수적 관계 : 원을 그리지 않음
- 선택적 관계 : 관계선 끝에 원을 그림
1. Barker 표기법
- 필수적 관계 : 실선
- 선택적 관계 : 점선

### 엔터티(Entity)

엔터티 : ‘독립체’, 데이터를 표현하는 데 있어서 최소한의 단위

(엔터티 : Table, 인스턴스 : Row, 속성 : Column)

**엔터티의 특징**

- 업무에서 쓰이는 정보여야 함
- 식별자가 있어야 함
- 2개 이상의 인스턴스를 가지고 있어야 함
- 반드시 속성을 가지고 있어야 함
- 다른 엔터티와 1개 이상의 관계를 가지고 있어야 함

**엔터티의 분류**

1. 유형 vs 무형
- 유형 엔터티 : 물리적인 형태 존재    ex) 상품, 회원
- 개념 엔터티 : 물리적인 형태 없음    ex) 부서, 학과, 보험상품
- 사건 엔터티 : 행위를 함으로써 발생    ex) 주문, 이벤트 응모
1. 발생시점
- 기본 엔터티 : 업무에 원래 존재하는 정보, 자신의 고유한 주식별자를 가짐    ex) 상품, 회원
- 중심 엔터티 : 기본 엔터티로부터 파생, 많은 데이터 양 ex) 주문, 매출, 계약
- 행위 엔터티 : 2개 이상의 엔터티로부터 파생, 초기단계 보다는 상세 설계단계에서 도출 ex) 주문 내역, 이벤트 응모 이력 등

### 속성(Attribute)

속성: 사물이나 개념의 특징을 설명해줄 수 있는 항목들, 의미상 분리되지 않는 최소의 데이터 레벨

**속성의 특징**

- 업무에서 쓰이는 정보여야 함
- 정해진 주식별자에 함수적 종속성을 가짐
- 하나의 속성은 한 개의 값(원자성)
- 하나의 속성에 여러 개의 값이 있으면 별도의 엔터티로 분리
- 하나의 인스턴스는 하나의 속성값
    
    함수적 종속성
    
    - 완전 함수적 종속 : 특정 컬럼이 기본키에 대해 완전히 종속
    
    → (주문번호 + 제품번호)에 대해 수량 컬럼의 값 결정
    
    - 부분 함수적 종속 : 기본키 일부에 대해 종속
    
    → 학생번호와 과목이 PK라 가정할 때, 과목에 의해서도 강사가 결정됨
    

**엔터티, 인스턴스, 속성, 속성값의 관계**

- 한 개의 엔터티는 두 개 이상의 인스턴스를 가짐
- 한 개의 엔터티는 두 개 이상의 속성을 가짐
- 한 개의 속성은 하나의 속성값을 가짐

**속성의 분류**

1. 특성에 따른 분류
- 기본속성 : 업무로부터 추출된 모든 속성    ex) 원금, 예치기관
- 설계속성 : 업무에 존재하지는 않지만 설계하다 보니 필요하다고 판단되어 도출해낸 속성, 유니크함을 부여 ex) 이름, 학과, 학년이라는 속성이 있을 때 학번이라는 설계속성으로 유니크함 부여
- 파생속성 : 빠른 성능, 다른 속성으로부터 파생된 속성, 일반적으로 계산된 값들이 해당
1. 구성방식에 따른 분류
- PK속성 : 각 인스턴스에 유니크함을 부여하는 속성
- FK속성 : 다른 엔터티와 관계를 맞게 해주는 매개체 역할을 하는 속성(다른 엔터티의 속성에서 가져옴
- 일반속성 : PK, FK를 제외한 나머지
1. 분해여부에 따른 분류
- 단일속성 : 하나의 의미로 구성    ex) 회원ID, 이름
- 복합속성 : 여러 개의 의미로 구성    ex) 주소(시/동)
- 다중값속성 :  속성에 여러 개의 값 가짐    ex) 상품 리스트

도메인 : 속성이 가질 수 있는 속성값의 범위

### 관계(Relationship)

엔터티와 엔터티와의 관계

- 존재 관계 : 존재 자체로 연관성이 있는 관계
- 행위 관계 : 특정 행위를 함으로써 연관성이 생기는 관계

**관계 표기법**

- 관계명 : 엔터티와 엔터티가 어떠한 관계를 맺고 있는지를 나타내주는 문장
- 관계차수 : 각 엔터티에서 관계에 참여하는 수를 의미
    - 1 : 1 관계
        - 완전 1대1 관계 : 반드시 하나 대응    ex) 사원은 반드시 소속 부서가 있어야
        - 선택적 1대1 관계 : 없을 수 있는 경우    ex) 사원은 하나의 소속 부서가 있거나 아직 발령 전이면 없을 수 있음
    - 1 : M 관계
    - N : M 관계
- 관계선택사양
    - 필수적 관계 : 참여자가 반드시 존재
    - 선택적 관계 : 참여자가 없을 수 도 있음

### 식별자

식별자 : 각각의 인스턴스를 구분 가능하게 만들어주는 대표격인 속성(논리 모델링에서는 식별자, 물리 모델링에서는 키(key)로 표현)

**주식별자의 특징**

- 유일성 : 각 인스턴스에 유니크함을 부여하여 식별 가능하게
- 최소성 : 유일성을 보장하는 최소 개수의 속성이어야
- 불변성 : 속성값이 되도록 변하지 않아야
- 존재성 : 속성값이 NULL일 수 없음

**식별자 분류**

1. 대표성 여부
- 주식별자 : 대표식별자    ex) 학생이라는 엔터티가 있으면 학번
- 보조식별자 : 인스턴스를 식별할 수는 있지만 대표식별자는 아님    ex) 주민번호
1. 스스로 생성되었는지 여부
- 내부식별자 : 엔터티 내부에서 스스로 생성된 식별자
- 외부식별자 : 다른 엔터티와의 연결고리 역할(FK)
1. 단일 속성의 여부
- 단일식별자 : 하나의 속성으로 구성
- 복합식별자 : 두 개 이상의 속성으로 구성
1. 대체 여부
- 원조(본질)식별자 : 업무 프로세스에 존재하는 식별자
- 대리(인조)식별자 : 주 식별자의 속성이 두 개 이상인 경우 그 속성들을 하나로 묶어서 사용함. 
인위적으로 만들어짐, 자동 증가하는 일련번호의 형태

**식별자 관계 vs 비식별자 관계**

- 식별자 관계 : 부모 엔터티의 식별자가 자식 엔터티의 주식별자가 되는 관계 → 하나의 엔터티의 기본키가 다른 엔터티의 기본키의 하나로 공유 (실선!!)
- 비식별자 관계 : 부모 엔터티의 식별자가 자식 엔터티의 주식별자가 아닌 일반속성이 되는 관계 → 강한 개체의 기본키를 다른 엔터티의 일반속성 중 하나로 공유 (점선!!)
    
    관계 간 엔터티 구분
    
    - 강한 개체 : 독립적으로 존재    ex) 고객/계좌 → 고객이 독립적
    - 약한 개체 : 독립적 존재 X    ex) 고객/계좌 → 계좌가 의존적

key의 종류

- 기본 키(Primary Key) : 엔터티를 대표하는 키
- 후보 키(Candidate Key) : 유일성과 최소성을 만족하는 키, 결국 후보 키중 하나가 기본 키가 되고, 나머지를 대체 키라 부름
- 슈퍼 키(Super Key) : 유일성은 만족하지만 최소성 만족 X    ex) 학생 테이블에서 학번으로만 PK를 구성해도 되지만, 학번+이름으로 구성한다면 이는 슈퍼 키
- 대체 키(Alternate Key) : 여러 후보 키 중 기본 키가 아닌 것
- 외래 키(Foreign Key) : 다른 테이블의 기본 키를 참조하는 키, 참조 테이블은 여러 개 가능

### 정규화

엔터티를 작은 단위로 분리하는 과정

데이터 조회 성능은 처리조건에 따라 향상 / 저하

데이터 입력, 수정, 삭제 성능은 일반적으로 향상

데이터 중복 제거, 모델의 독립성 확보, 이상현상을 줄임

논리적 데이터 모델링 과정해서 수행!

1. **제 1 정규형**

모든 속성은 반드시 하나의 값만 가져야 함(원자성)

→ 유사한 속성이 반복되는 경우!

1. **제 2 정규형**

제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만들도록 분해(기본 키를 구성하는 모든 컬럼의 값이 다른 컬럼을 결정짓는 상태)

→ 일반속성이 주식별자의 일부 속성에 종속되었을 때!

1. **제  3 정규형**

제 2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블 분리(A→B, B→C 가 성립할 때 A→C가 성립하는 것)

→ 일반속성이 일반속성에 종속되었을 때!

### 트랜잭션

트랜잭션 : 데이터를 조작하기 위한 하나의 논리적(연속적)인 작업 단위 → 트랜잭션에 의한 관계는 필수적인 관계 형태(A가 있으면 무조건 B도 따라와야해!)

주의) A와 B가 독립적으로 발생하면 안됨!(각각의 INSERT로 개발 X)
          부분 COMMIT 불가(동시 COMMIT 또는 ROLLBACK 처리)

### NULL

NULL : 값이 존재하지 않음, 정의되지 않음, 없음

**NULL의 특징**

- NULL을 포함한 연산 결과는 항상 NULL

→ 치환을 하면 정상적으로 나옴!

- 집계함수는 NULL을 제외한 연산결과 리턴 (SUM, AVG, MIN, MAX 등의 함수는 항상 NULL 무시)

같은 인스턴스에서 NULL값 계산 시(가로 계산) → NULL이 포함되어 있으면 결과값도 NULL

다른 인스턴스에서 NULL값 계산 시(세로 계산)→NULL 값을 제외하고 계산
RDB : 관계형 데이터베이스

RDBMS : 이러한 RDB를 관리, 감독하기 위한 시스템

**RDB의 구성요소**

- 계정 : 데이터의 접근 제한을 위한 여러 업무별/시스템별 계정 존재
- 테이블 : DBMS의 DB안에서 데이터가 저장되는 형식
- 스키마 : 테이블이 어떤 구성으로 되어있는지, 어떠한 정보를 가지고 있는지에 대한 기본적 구조

엔터티 → 물리 모델링에서 테이블(TABLE)!!

**데이터 무결성** : 데이터의 정확성과 일관성을 유지하고, 데이터에 결손과 부정합이 없음을 보증

- 개체 무결성 : 기본 키에는 NULL X, 중복값 X
- 참조 무결성 : 외래 키에는 NULL O, 참조 테이블의 기본키 값과 동일해야
- 도메인 무결성 : 속성값이 도메인(범위) 안이어야
- NULL 무결성 : 특정 속성에 대해 NULL 허용 X
- 고유 무결성 : 특정 속성에 대해 중복값 X
- 키 무결성 : 하나의 관계에는 적어도 하나의 조인 키가 필요

**SQL 종류**

- DDL(Data Definition Language) : CREATE, ALTER, DROP, TRUNCATE
- DML(Data Manipulation Language) : INSERT, DELETE, UPDATE, MERGE
- DCL(Data Control Language) : GRANT, REVOKE
- TCL(Transaction Control Language) : COMMIT, ROLLBACK
- DQL(Data Query Language) : SELECT

### SELECT 문

**SELECT 문 구조**

SELECT * / 컬럼명 / 표현식

FROM 테이블명 또는 뷰명

WHERE 조회조건 (행 필터링)

GROUP BY 그룹핑 컬럼명 (연산 ex. 평균)

HAVING 그룹핑 필터링 조건 (연산 추가조건)

ORDER BY 정렬 컬럼명

FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY 순으로 실행됨(내부 파싱)

Alias를 지정해주지 않으면 컬럼명은 기본적으로 대문자로 출력!!

### 함수

**문자 함수**

- LOWER(문자열) : 문자열을 소문자로
- UPPER(문자열) : 문자열을 대문자로
- LTRIM(문자열, [특정 문자]): 특정 문자를 명시해주지 않으면 왼쪽 공백 제거
               명시해주었을 경우 포함되어 있으면 제거, 포함되지 않았으면 멈춤
- RTRIM(문자열, [특정 문자]) : 특정 문자를 명시해주지 않으면 오른쪽 공백 제거
               명시해주었을 경우 포함되어 있으면 제거, 포함되지 않았으면 멈춤
- TRIM([위치], [특정 문자], [FROM], 문자열) : 문자열의 왼쪽과 오른쪽 공백 제거
- SUBSTR([문자열, M, [N]) : M위치에서 N개의 문자열 추출
- INSTR(대상, 찾을 문자열, M, N) : M위치에서 시작해서 N 번째 발견된 문자열 위치 반환
→ M이 음수일 때 역방향으로 찾기 시작
- LENGTH(문자열) : 문자열의 길이 반환
- CONCAT(대상1, 대상2…) :  문자열 결합
- REPLACE(문자열, 변경 전 문자열, [변경 후 문자열]) : 변경 전 문자열을 찾아 제거하고, 변경 후 문자열을 대체
- TRANSLATE(대상, 찾을 문자열, 바꿀 문자열) : 글자를 1대1로 치환
- LPAD(문자열, 길이, 문자) : 대상 왼쪽에 문자열을 계속 추가하여 길이만큼을 반환
- RPAD(문자열, 길이, 문자) : 대상 오른쪽에 문자열을 계속 추가하여 길이만큼을 반환

**숫자함수**

- ABS(수) : 절댓값 반환
- SIGN(수) : 수의 부호 반환, 양수이면 1 / 음수이면 -1 / 0이면 0 반환
- ROUND(수, [자릿수]) : 지정된 소수점 자릿수까지 반올림해서 반환
                                          자릿수 명시하지 않았을 경우 기본값은 0, 반올림된 정수
                                          자릿수가 음수일 경우 지정된 정수부 반올림 (163.76 → 200)
- TRUNC(수, [자릿수]) : 지정된 소수점 자릿수까지 버림하여 반환
                                         자릿수 명시하지 않았을 경우 기본값은 0, 버림된 정수
                                         자릿수가 음수일 경우 지정된 정수부 버림 (54.29 → 50)
- CEIL(수) : 크거나 작은 최대 정수 리턴
- FLOOR(수) : 작거나 같은 최대 정수 리턴
- MOD(수1, 수2) : 수1을 수2로 나눈 나머지를 반환, 수2가 0일 경우 수 1을 반환
- POWER(M, N) : M의 N 거듭제곱
- SQRT(숫자) : 루트 값 리턴

**그룹함수 (다중행 함수)**

→ 여러 값이 INPUT으로 들어가서 하나의 요약된 값으로 리턴

- COUNT(대상) : 행의 수 리턴
- SUM(대상) : 총 합 리턴
- AVG(대상) : 평균 리턴
- MIN(대상) : 최솟값 리턴
- MAX(대상) : 최댓값 리턴
- VARIANCE(대상) : 분산 리턴
- STDDEV(대상) : 표준편차 리턴

모두 NULL은 무시하고 리턴!!(가로 계산은 NULL 들어가면 무조건 NULL, 세로 계산은 무시하고 GO)

**변환 함수**

암시적 형변환 : 데이터베이스가 내부적으로 알아서 데이터 유형을 반환함

명시적 형변환 : 변환 함수를 사용하여 데이터 유형 변환을 명시적으로 나타냄

- TO_NUMBER(문자열) : 문자열을 숫자형으로 변환
- TO_CHAR(수 or 날짜, [포맷]) : 수나 날짜형의 데이터를 포맷 형식의 문자형으로 변환
- TO_DATE(문자열, 포맷) : 포맷 형식의 문자형의 데이터를 날짜형으로 변환

**NULL 관련 함수**

- DECODE(대상, 값1, 리턴1, 값2, 리턴2, ….. [그 외 리턴]) : 대상이 값1 이면 리턴1, 값2면 리턴2 … 그 외에는 그 외 리턴값 리턴, [그 외 리턴] 생락시 NULL 리턴
- NVL(대상, 치환값) : 대상의 값이 NULL이 아닐경우 그대로 반환
                                    대상의 값이 NULL일 경우 치환값 반환
- NULLIF(인수1, 인수2) : 인수1과 인수2가 같으면 NULL 반환, 같지 않으면 인수1 반환
- COALESCE(인수1, 인수2, 인수3 …) : NULL이 아닌 최초의 인수의 반환
- NVL2(대상, 치환값1, 치환값2): 대상의 값이 NULL이 아닌 경우 치환값1을 반환
                                                          대상의 값이 NULL인 경우 치환값2 반환
- ISNULL(대상, 치환값) : 대상 그 자체가 NULL 이면 치환값 리턴

**CASE**

문법) CASE WHEN 조건 THEN 수행
                                             ELSE 나머지 수행
            END

동일한 대상 & =조건 일 때 축약해서 작성 가능
EX) CASE WHEN SUBWAY_LINE = ‘1’ ….    → CASE SUBWAY_LINE WHEN ‘1’….

- CASE 와 WHEN 사이에 아무것도 없다 → 풀 조건
- CASE와 WHEN 사이에 대상이 있다 → 축약 조건

### FROM 절

데이터를 불러올 테이블명 또는 뷰명 전달

테이블 별칭(ALIAS) 설정 가능 (ORACLE에서는 AS 사용 불가 / SQL SERVER에서는 사용, 생략 가능)

ORACLE에서는 FROM절 생략 불가(의미 없을 때 DUAL 테이블 선언)

SQL SERVER에서는 FROM절 필요 없을 때 생락 가능

### WHERE 절

원하는 데이터만 골라 수행할 수 있도록 해주는 구문

여러 조건 동시 전달 가능(AND/OR)  

NULL 조회 시 IS NULL / IS NOT NULL

문자나 날짜 상수 표현 시 반드시 홑따옴표 사용!!!

WHERE절에서는 집계함수 사용 불가, 비교연산자로 비교해야

**비교연산자**

- ! = : 같지 않음
- ^ = : 같지 않음
- < > : 같지 않음

**SQL 연산자**

- BETWEEN A AND B : A와 B 사이
- LIKE ‘비교 문자열’ : 특정 패턴을 가지고 있는 조건 검색
→ 정확하게 일치하지 않아도 되는 패턴 조건 전달 시 사용
    % 와 _ 와 함께 사용됨
    - % : 자리수 제한 없는 모든이라는 의미
    - _ : _하나당 한 자리수를 의미하며 모든 값 표현
    
    ex) ENAME LIKE ‘S%’ : 이름이 S로 시작하는
           ENAME LIKE ‘%S%’ : 이름에 S를 포함하는
           ENAME LIKE ‘_S%’ : 이름의 두 번째 글자가 S인
    
- IN (LIST) : LIST 중 하나와 일치
- IS NULL : NULL 값
- IS NOT NULL : NULL 값이 아닌 값

**논리 연산자**

- AND : 모든 조건이 TRUE 여야 함
- OR : 하나 이상의 조건이 TRUE 여야 함
- NOT : TRUE면 FASLE이고 FALSE이면 TRUE

항상 () → NOT → AND → OR 순으로 처리됨!!

### GROUP BY, HAVING 절

**GROUP BY절** : 데이터를 그룹별로 묶을 수 있도록 해주는 절

만약 그룹연산에서 제외 할 대상이 있다면 WHERE절에서 해당 행을 제거

GROUP BY절을 사용하면 데이터가 요약되므로 요약되기 전 데이터와 함께 출력 불가

**HAVING 절** : GROUP BY 절을 사용할 때 WHERE 절처럼 사용하는 조건절

그룹핑 후에 가능한 집계함수로 조건을 부여할 수 있음

내부적 연산 순서가 SELECT절보다 먼저니까 SELECT절에서 선언된 ALIAS 사용 불가!!

### ORDER BY 절

SELECT문에서 논리적으로 맨 마지막에 수행됨

ORDER BY절을 사용하여 SELECT한 데이터를 정렬할 수 있음

따로 명시하지 않으면 데이터는 임의의 순서대로 출력됨

- ASC : 오름차순
- DESC : 내림차순

옵션 생략시 기본값 오름차순!

- ORACLE: NULL 최댓값 취급
- SQL SERVER : NULL 최솟값 취급

ORDER BY 절에는 컬럼명을 명시해줄 수도 있고 SELECR절에 기술된 컬럼의 순서를 숫자로 명시해줄 수도 있음!!

→ 복합정렬 : 먼저 정렬한 값의 동일한 결과가 있을 경우 추가적으로 정렬!
                         1차 정렬값이 같은 경우 그 안에서 2차 정렬값이 일어남

### JOIN

각기 다른 테이블을 한 번에 보여줄 때 쓰이는 쿼리

FROM절에 조인할 테이블 나열

동일한 열 이름이 여러 테이블에 존재할 경우 열 이름 앞에 테이블 이름이나 테이블 ALIAS 붙임!

N개의 테이블을 조인하려면 N-1 개의 조인 조건 필요

WHERE 절에서 조인 조건 작성(ORACLE)

- ORACLE 표준은 테이블 나열 순서 중요 X
- ANSI 표준은 OUTER JOIN시 순서 중요(테이블과 테이블 사이에 조인의 종류 작성)

문법) FROM 절에 조인하고자 하는 테이블을 모두 명시
           FROM 절에 명시하는 테이블은 테이블 별칭 사용 가능
           WHERE절에 두 테이블의 공통 컬럼에 대한 조인 조건 나열

**조인 종류**

1. 조건의 형태에 따라
- EQUI JOIN : JOIN 조건이 동등 조건인 경우(=)
- NON EQUI JOIN : JOIN 조건이 동등 조건이 아닌 경우
1. 조인 결과에 따라
- INNER JOIN : JOIN 조건에 성립하는 데이터만 출력
- OUTER JOIN : JOIN 조건에 성립하지 않는 데이터도 출력
(LEFT / RIGHT / FULL OUTER JOIN으로 나뉨)
1. NATURAL JOIN : 조인 조건 생략 시 두 테이블에 같은 이름으로 자연 연결되는 조인
2. CROSS JOIN : 조인 조건 생략 시 두 테이블의 발생가능한 모든 행을 출력
3. SELF JOIN : 하나의 테이블을 두 번 이상 참조하여 연결하는 조인

 **EQUI JOIN**

동등 조건으로 JOIN 하는 방식

NULL은 동등 조건에 포함 X

**NON EQUI JOIN**

동등 조건이 아닌 다른 조건(BETWEEN, >, >= < , <=) 으로 JOIN하는 방식

**SELF JOIN**

한 테이블 내 각 행끼리 관계를 갖는 경우 조인 기법

한 테이블을 참조할 때마다 (필요할 때마다) 명시해야 함

테이블명이 중복되므로 반드시 테이블 별칭 사용

<ANSI JOIN / 표준 조인>

ANSI 표준의 경우 ON 이나 USING 조건절을 필수적으로 사용!

- ON 절 : 조인할 양 컬럼의 컬럼명이 서로 다르더라도 사용 가능
               ON 조건의 괄호는 옵션(생략가능)
               ON 조건절에서 조인 조건 명시!!
               WHERE 조건절에서는 일반 조건 명시
- USING 절 : 조인할 컬럼명이 같을 경우 사용
                     ALIAS나 테이블 이름 같은 접두사 붙이기 불가
                     괄호 사용 필수

**INNER JOIN**

JOIN 조건에 충족하는 데이터만 출력되는 방식

ANSI 표준의 경우 FROM 절에 INNER JOIN 혹은 줄여서 JOIN 명시

ORACLE 표준의 경우 INNER JOIN이 기본 조인 연산이므로 별도 문법 존재 X

**OUTER JOIN**

JOIN 조건에 충족하는 데이터가 아니어도 출력되는 방식

ORACLE 에서는 모든 행이 출력되는 테이블의 반대편 테이블의 옆에 (+) 기호를 붙여 작성!!

- LEFT OUTER JOIN : 왼쪽에 표기된 테이블의 데이터는 무조건 출력됨
                           오른쪽 테이블에 JOIN되는 데이터가 없는 ROW들은 오른쪽 컬럼값이 NULL로 출력
- RIGHT OUTER JOIN : 오른쪽에 표기된 테이블의 데이터는 무조건 출력됨
                                    왼쪽 테이블에 JOIN되는 데이터가 없는 ROW들은 왼쪽 컬럼값이 NULL로 출력
- FULL OUTER JOIN : 왼쪽, 오른쪽 테이블의 데이터가 모두 출력되는 방식(단, 중복값은 제거)

**NATURAL JOIN**

A테이블과 B테이블에서 같은 이름을 가진 컬럼들이 모두 동일한 데이터를 가지고 있을 경우 JOIN

JOIN에 사용된 컬럼들은 데이터 유형이 동일해야 하며 공통 컬럼 앞에 접두사(별칭) 사용 불가

USING, ON, WHERE 에서 조건 정의 불가

**CROSS JOIN**

A테이블과 B테이블 사이에 JOIN조건이 없는 경우, 조합할 수 있는 모든 경우를 출력하는 방식

Cartesian Product 라고 표현하기도 함

### 서브쿼리

바깥에 있는 엄마쿼리를 메인쿼리, 안에 있는 아기쿼리를 서브쿼리라고 부름

서브쿼리절에 ORDER BY절은 사용불가!!

**위치에 따라**

- SELECT절 : 스칼라 서브쿼리
- FROM절 : 인라인 뷰
- WHERE절, HAVING절 : 중첩 서브쿼리

**스칼라 서브쿼리**

주로 SELECT절에 위치

컬럼 대신 사용되므로 반드시 하나의 값만을 반환해야 함
→ 한 행의 한 열 반환!!!

조인의 대체연산

스칼라 서브쿼리를 사용한 조인 처리시 OUTER JOIN이 기본(값이 없더라도 생략되지 않고 NULL 출력)

→ 서브쿼리 결과를 하나의 컬럼처럼 사용하기 위해 주로 사용(이 테이블에 존재하지 않는 컬럼 조인 느낌)

**인라인뷰**

항상 FROM절에 위치

→ 서브쿼리 결과를 테이블처럼 사용하기 위해 주로 사용

**중첩 서브쿼리**

주로 WHERE절과 HAVING절에 위치

- 비연관 서브쿼리 : 메인쿼리의 컬럼이 포함되지 않은 서브쿼리
- 연관 서브쿼리 : 메인쿼리의 컬럼이 포함된 서브쿼리

→ 메인쿼리와 서브쿼리의 비교를 수행하는 형태
     대소비교할 컬럼을 메인쿼리에, 일치 조건을 서브쿼리에 전달

반환하는 데이터 형태에 따라

- **단일 행 서브쿼리** : 한 행의 데이터 반환
                                   단일 행 비교연산자 이용!!!
    - =, <> 등등등….
- **다중 행 서브쿼리** : 여러 행의 데이터 반환
                                  다중 행 비교연산자 사용!!!
    - IN : 같은 값을 찾음
    - >ANY : 최소값 반환
    - <ANY : 최대값 반환
    - >ALL : 최대값 반환
    - <ALL : 최소값 반환
    - SOME, EXISTS 등등등…
- 다중컬럼 서브쿼리 : 서브쿼리 결과가 여러 컬럼이 리턴되는 형태
                                      메인쿼리와의 비교 컬럼이 2개 이상
                                       대소비교 전달 불가(같을 때만)

### 뷰

쿼리 안에 뷰의 형태로 테이블처럼 조회할 데이터를 정의하기 위해 사용

테이블명이 존재하지 않기 때문에 다른 테이블과 조인 시 반드시 테이블 별칭 명시!!

WHERE절 서브쿼리와 다르게 서브쿼리 결과를 메인쿼리 어느 절에서도 사용할 수 있음

인라인뷰의 결과와 메인쿼리 테이블과 조인할 목적으로 사용

**특성**

- 보안성 : 보안이 필요한 테이블의 경우 별도의 뷰를 생성함으로써 보안 유지
- 독립성 : 테이블 스키마가 변경되었을 경우 애플리케이션 수정X, 관련 뷰만 수정
- 편리성 : 복잡한 쿼리 구문 뷰명으로 단축시켜 가독성 높이고 편리하게

### 집합 연산자

각 쿼리의 결과 집합을 가지고 연산을 하는 명령어

- UNION ALL : 합집합, 중복된 행도 그대로 출력
- UNION : 합집합, 중복된 행은 한 줄로 출력
- INTERSECT : 교집합, 중복된 행은 한 줄로 출력
→ 헤더 값(PK)는 첫 번째 쿼리 따라감!
- MINUS/EXCEPT : 차집합, 중복된 행은 한 줄로 출력

**집합 연산자 사용 시 주의사항**

- 두 집합의 컬럼 수 일치
- 두 집합의 컬럼 순서 일치
- 두 집합의 각 컬럼의 데이터 타입 일치
- 각 컬럼의 사이즈는 달라도 됨
- 개별 SELECT문에 ORDER BY 절 전달 불가(GROUP BY는 가능)

### 그룹 함수

데이터를 GROUP BY 하여 나타낼 수 있는 데이터를 구하는 함수

집계 함수 : COUNT, SUM, AVG, MAX, MIN 등

소계(총계) 함수 : ROLLUP, CUBE, GROUPING SETS 등

**ROLLUP(A, B)**

→ A별, (A, B)별 그룹 연산 결과 출력

나열 대상의 순서가 중요함

기본적으로 전체 총계가 출력됨

UNION ALL로 대체 가능

**CUBE(A, B)**

→ A별, B별, (A,B)별 그룹 연산 결과 출력

나열 대상의 순서 중요하지 않음

기본적으로 전체 총계가 출력됨

UNION ALL로 대체 가능

**GROUPING SETS(A, B)**

→ A별, B별 그룹 연산 결과 출력

나열된 컬럼마다 GROUP BY연산 결과 출력

나열 대상의 순서 중요하지 않음

기본적으로 전체 총계가 출력X (총계 출력하려면 마지막에 ( ) 추가 OR ROLLUP 함수 안에 넣기)

### 윈도우 함수

OVER 키워드와 함께 사용

문법) SELECT 윈도우 함수([대상])
           OVER( [PARTITION BY 컬럼]
                        [ORDER BY 컬럼 ASC ㅣ DESC]
                        [ROWS ㅣ RANGE BETWEEN A AND B]) ;

PARTITION BY 절 : 출력할 총 데이터 수 변화 없이 그룹연산 수행할 GROUP BY 컬럼

ORDER BY 절 : RANK의 경우 필수!(정렬 컬럼 및 정렬 순서에 따라 순위 변화)
                           SUM, AVG, MIN, MAX, COUNT 등은 누적 값 출력 시 사용

ROWS ㅣ RANGE BETWEEN A AND B : 연산 범위 설정, ORDER BY 절 필수

→ ROWS, RANGE 차이

- ROWS : 값이 같더라도 각 행씩 연산
- RANGE : 같은 값의 경우 하나의 RANGE로 묶어서 동시 연산

→ BETWEEN A AND B

1. 시작점(A) 정의
- CURRENT ROW : 현재 행부터
- UNBOUNDED PRECEDING : 처음부터 (기본값!)
- N PRECEDING : N(값)이전부터
1. 마지막 시점(B) 정의
- CURRENT ROW : 현재 행까지 (기본값!)
- UNBOUNDED FOLLOWING : 마지막까지
- N FOLLOWING : N(값) 이후까지

서로 다른 **행**의 비교나 연산을 위해 만든 함수! (각 행마다 계산된 값을 반환)

GROUP BY를 쓰지 않고 그룹 연산이 가능! 

- 순위 함수 : RANK, DENSE_RANK, ROW_NUMBER
- 집계 함수 : SUM, MAX, MIN, AVG, COUNT
- 행 순서 함수 : FIRST_VALUE, LAST_VALUE, LAG, LEAD
- 비율 함수 : CUME_DIST, PERCENT_RANK, NTILE, RATIO_TO_REPORT

**순위 함수**

- RANK : 같은 순위가 존재하면 존재하는 수만큼 다음 순위를 건너뜀
→ 1, 2, 2, 4
- DENSE RANK : 같은 순위가 존재하더라도 다음 순위를 건너뛰지 않고 매김
→ 1, 2, 2, 3
- ROW_NUMBER : 동일한 값이라도 각기 다른 순위 부여
→ 1, 2, 3, 4

**집계 함수**

- SUM : 합계
→ OVER절 내에 ORDER BY 절을 쓰면 데이터 누적값 집계!
- MAX : 최댓값
- MIN : 최솟값
- AVG : 평균
- COUNT : 행의 수

**행 순서 함수**

- FIRST_VALUE : 파티션별 가장 선두에 위치한 데이터를 구함
→ 범위를 어떻게 설정하냐에 따라 최대/최소 리턴 가능
- LAST_VALUE : 파티션 별 가장 끝에 위치한 데이터를 구함
→ 범위를 어떻게 설정하냐에 따라 최대/최소 리턴 가능
주의) ORDER BY 절 뒤에 아무것도 명시해주지 않았을 경우 RANGE UNBOUNDED PRECEDING이 기본값이 되어 맨 위 행부터 현재 행까지가 범위가 됨!! → 내림차순에서 마지막 데이터를 출력해 주려면 UNBOUNDED FOLLOWING을 반드시 명시해줘야 함!!
- LAG : 파티션별로 특정 수만큼 앞선 데이터를 구하는 함수
           ORDER BY 절 필수!!
           기본값으로 1개 앞에 값을 가져옴
- LEAD : 파티션별로 특정 수만큼 뒤에 있는 데이터를 구하는 함수
             ORDER BY절 필수!!
             기본값으로 1개 뒤의 값을 가져옴

**비율함수**

- RATIO_TO_REPORT : 파티션별 합계에서 차지하는 비율을 구하는 함수
                                      ORDER BY절 사용 불가!!
                                      전체비율 또는 특정그룹 내 비율 가능!!
- PERCENT_RANK : 해당 파티션의 맨 위 끝 행을 0, 맨 아래 끝 행을 1로 놓고 현재 행!!!이 위치하는 백분위 순위 값을 구하는 함수
                                  ORDER BY 절 필수!!
- CUME_DIST : 해당 파티션에서의 누적 백분율을 구하는 함수
                            ORDER BY 절 필수!!
                            특정 값이 전체 데이터 집합에서 차지하는 위치를 백분위수로 계산하여 출력
- NTILE : 주어진 수만큼 행들을 N등분한 후 현재 행!!!에 해당하는 등급을 구하는 함수
              ORDER BY 절 필수!!
               PARTITION BY를 사용하여 특정그룹을 또 원하는 수만큼 그룹 분리 가능

### TOP-N 쿼리

TOP N위까지 추출하겠다는 의미

**ROWNUM**

출력된 데이터 기준으로 행 번호 부여

절대적인 행 번호가 아닌 가상의 번호이므로 특정 행 지정 불가!! ( = 연산 불가)

첫 번째 행이 증가한 이후 할당되므로 > 연산 사용 불가

→ 항상 < 조건이나 <= 조건으로 사용해야 함

**FETCH절**

출력될 행의 수를 제한하는 절

ORACLE 12C 이상부터 제공

문법) SELECT
           FROM …
           ORDER BY
           OFFSET N {ROW ㅣ ROWS}
           FETCH {FIRST ㅣ NEXT} N {ROW ㅣ ROWS} ONLY

- OFFSET  N : 건너뛸 행의 수 N행
- FETCH : 출력할 행의 수를 전달하는 구문
- FIRST : OFFSET을 쓰지 않았을 때 처음부터 N행 출력 명령
- NEXT N : OFFSET을 사용했을 경우 제외할 행 다음부터 N행 출력 명령

**TOP-N 쿼리**

SQL SERVER에서 상위 N개 추출

서브쿼리 사용 없이 하나의 쿼리로 정렬된 순서대로 상위 N개 추출 가능

WITH TIES를 사용하여 동순위까지 출력 가능

문법) SELECT TOP N 컬럼1, 컬럼2 …
           FROM 테이블명
           OREDER BY 정렬컬럼명[ASC/DESC]…

**윈도우 함수**

RANK 함수나 DENSE_RANK 등을 사용해서 순위를 매기고 출력 가능

### 셀프 조인

FROM절에 같은 테이블이 두 번 이상 등장하기 때문에 ALIAS를 반드시 표기해주어야 함!!

### 계층 쿼리

하나의 테이블 내 각 행끼리 관계를 가질 때, 연결고리를 통해 행과 행 사이의 계층(DEPTH)를 표현

테이블에 계층 구조를 이루는 컬럼이 존재할 경우!!

PRIOR의 위치에 따라 연결 데이터가 달라짐(순방향 / 역방향)

- PRIOR 부모열 = 자식열 : PRIOR이 왼쪽에 사용되면, 부모에서 자식으로 내려가는 순방향
- 부모열 = PRIOR 자식열 : PRIOR이 오른쪽에 사용되면, 자식에서 부모로 올라가는 역방향

문법) SELECT 컬럼명
           FROM 테이블명
           STRAT WITH 시작 조건
           CONNECT BY [NOCYCLE] PRIOR 연결조건;

- LEVEL : 현재의 DEPTH를 반환, 루트노드가 1
- SYS_CONNECT_BY_PATH(컬럼, 구분자) : 루트 노드로부터 현재 노드까지의 경로를 출력해줌
- START WITH : 경로가 시작되는 루트 노드를 생성해주는 절
- CONNECT BY : 루트로부터 자식 노드를 생성해주는 절, 조건에 만족하는 데이터가 없을 때까지 노드를 생성함
- PRIOR : 바로 앞에 있는 부모 노드의 값을 반환
→ CONNECT BY절 외에 SELECT, WHERE절에서도 사용 가능!!
- CONNECT_BY_ROOT 컬럼 : 루트 노드의 주어진 컬럼 값을 반환
- ORDER SIBLINGS BY 컬럼 : 같은 LEVEL일 경우 정렬 수행 → 계층 구조를 유지할 수 있음
- CONNECT_BY_ISLEAF : 가장 하위 노드인 경우 1을 반환하고 그 외에는 0 반환
- CONNECT_BY_ISCYCLE : 계층형 쿼리의 결과에 순환이 발생했는지 여부

### PIVOT과 UNPIVOT

PIVOT : LONG(일반적 데이터 구조) → WIDE

UNPIVOT : WIDE → LONG

**PIVOT**

교차표를 만드는 기능

STACK컬럼, UNSTACK컬럼, VALUE컬럼의 정의가 중요

- FROM 절에 STACK, UNSTACK, VALUE 컬럼명만 정의
- PIVOT절에 UNSTACK, VALUE 컬럼명 정의
- PIVOT절 IN 연산자에 UNSTACK 컬럼값을 정의

| MONTH | 월 | 화 | 수 | 목 | 금 | 토 | 일 → UNSTACK 컬럼 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| (STACK 컬럼) |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  | VALUE 컬럼 |

문법) SELECT *
           FROM 테이블명 또는 서브쿼리
           PIVOT(VALUE 컬럼명 FOR UNSTACK 컬럼명, IN (값1, 값2, 값3 …)) ;

EX) SELECT *
       FROM(SELECT 년도, 성별, 구매량 FROM UNSTACK_TEST))
       PIVOT(SUM(구매량) FOR 년도 IN (2008, 2009));

→ 

| 성별 | 2008 | 2009 |
| --- | --- | --- |
| 남자 | 3 | 11 |
| 여자 | 7 | 9 |

**UNPIVOT**

- STACK 컬럼 : 이미 UNSTACK 되어있는 여러 컬럼을 하나의 컬럼으로 STACK시 새로 만들 컬럼 이름 (사용자 정의)
- VALUE 컬럼 : 교차표에서 셀 자리(VALUE)값을 하나의 컬럼으로 표현하고자 할 때 새로 만들 컬럼 명 (사용자 정의)
- 값1, 값2.. : 실제 UNSTACK 되어 있는 컬럼 이름들

문법) SELECT *
           FROM 테이블명 또는 서브쿼리
           UNPIVOT (VALUE컬럼명 FOR STACK 컬럼명 IN (값1, 값2, 값3…)) ;

EX) SELECT *
       FROM STACK_TEST
       UNPIVOT(CNT FOR 년도 IN (2008, 2009));

→ 

| 성별  | 년도 | CNT |
| --- | --- | --- |
| 남자 | 2008 | 3 |
| 남자 | 2009 | 11 |
| 여자 | 2008 | 7 |
| 여자 | 2009 | 9 |

### 정규 표현식

문자열의 공통된 규칙을 보다 일반화하여 표현하는 방법
EX) 숫자를 포함하는, 숫자로 시작하는 4자리, 두 번째 자리가 A인 5글자

**정규 표현식의 종류**

- \d : Digit(숫자)
- \D : 숫자가 아닌 것
- \s : 공백
- \S : 공백이 아닌 것
- \w : 단어
- \W : 단어가 아닌 것
- \t : Tab
- \n : New line(엔터 문자)
- [ab] : a또는 b의 한글자
- [^ab] : a와 b 제외한 모든 글자
- [0-9] : 숫자
- [A-Z] : 영어 대문자
- [a-z] : 영어 소문자
- [A-z] : 모든 영문자
- [:lower:] : 소문자
- [:upper:] : 대문자
- [:print:] : 숫자, 문자, 특수문자, 공백 모두
- [:punct:] : 특수문자
- [:space:] : 공백문자
- \n(숫자) : 그룹 번호

- i+ : i가 1회 이상 반복
- i* : i가 0회 이상 반복
- i? : i가 0회에서 1회 반복
- i{n} : i가 n회 반복
- i{n1, n2} : i가 n1회에서 n2회 반복
- i{n, } : i가 n회 이상 반복
- ^ : 시작되는 글자
- $ : 마지막 글자
- \ : 뒤에 기호 의미 제거(이스케이프 코드)
- ㅣ : 또는
- . : 엔터를 제외한 모든 한 글자
- [:alnum:] : 문자와 숫자
- [:alpha:] : 문자
- [:blank:] : 공백
- [:cntrl:] : 제어문자
- [:digit:] : 숫자
- [:graph:] : 공백이 아닌 모든 문자
- [:xdigit:] : 16진수
- () : 그룹 지정
    - 문자열의 ()은 이스케이프 코드로
    - 그룹 묶을 ()은 그냥()

EX) tel) 02-999-0456 / tel 02-999-0456  → tel\)? [0-9-]+

**REGEXP_REPLACE (대체)**

문법)

 (대상, 찾을문자열, [바꿀문자열], [검색위치], [발견횟수], [옵션])

바꿀문자열 생략시 문자열 삭제

검색위치 생략시 1

발견횟수 생략시 0

옵션 

- c : 대소구분 검색
- i : 대소구분x 검색
- m : 패턴을 다중라인으로 선언 가능

**REGEXP_SUBSTR (추출)**

문법)

(대상, 패턴, [검색위치], [발견횟수], [옵션], [추출그룹])

검색위치 생략시 1

발견횟수 생략시 0

추출그룹은 서브패턴을 추출시 그 중 추출할 서브패턴 번호

**REGEXP_INSTR (위치 리턴)**

문법)

(원본, 찾을 문자열, [시작위치], [발견횟수], [옵션])

시작위치 생략시 처음부터 확인

발견횟수 생략시 처음 발견된 문자열 위치 리턴

**REGEXP_LIKE (특정 패턴을 갖는 경우 리턴)**

문법)

(원본, 찾을문자열, [옵션])

옵션 REGEXP_REPLACE와 동일

**REGEXP_COUNT (특정패턴 횟수 리턴)**

문법)

(원본, 찾을문자열, [옵션])

옵션 REGEXP_REPLACE와 동일
### DML

Data Manipulation Language

→ COMMIT이나 ROLLBACK 반드시 필요!!

**INSERT**

컬럼별 데이터타입과 사이즈에 맞게 행을 삽입

문법)

INSERT INTO 테이블명(컬럼명1, 컬럼명2 ..) VALUES(데이터1, 데이터2..);

컬럼명이 선택되지 않으면 NULL이 입력됨!!

→ PK나 NOT NULL 제약조건이 걸린 컬럼에는 NULL 값 입력 불가!!

**UPDATE**

이미 저장된 데이터를 수정하고 싶을 때 사용

주의) WHERE절이 없으면 테이블의 모든 ROW가 변경!

문법)

UPDATE 테이블명 SET 수정할 컬럼명 = 수정 값 (WHERE 수정할 데이터에 대한 조건);

**DELETE**

이미 저장된 데이터를 삭제하고 싶을 때 사용

주의) WHERE절이 없으면 테이블의 모든 ROW가 삭제!

문법)

DELETE [FROM] 테이블명 (WHERE 수정할 데이터에 대한 조건);

**MERGE**

참조 테이블과 동일하게 맞추는 작업

INSERT, UPDATE, DELETE 동시에 수행

문법)

MERGE
  INTO 타겟 테이블명
USING 참조 테이블명
ON (조건)
WHEN MATCHED THEN
             UPDATE
                     SET 컬럼명 = 새로운 데이터 …
WHEN NOT MATCHED THEN
              INSERT [(컬럼명1, 컬럼명2 …)]
              VALUES(데이터1, 데이터2…)]

### TCL

Transaction Control Language

**트랜잭션의 특징**

- 원자성 : 트랜잭션으로 묶이면 모두 성공하거나 모두 실패
- 일관성 : 트랜잭션이 완료된 후에도 데이터베이스가 가진 데이터에 일관성이 있어야
- 고립성 : 하나의 트랜잭션은 고립성이 있어야
- 지속성 : 트랜잭션이 성공적으로 수행되었을 경우 데이터가 영구적이어야

**COMMIT**

COMMIT을 실행해야 최종적으로 데이터 파일에 기록이 되고 비로소 트랜잭션 완료

한번 COMMIT을 수행하면 COMMIT 이전에 수행된 DML은 모두 저장되며 되돌릴 수 없음

**ROLLBACK**

ROLLBACK을 하면 변경하기 이전 값으로 복구됨

최종 COMMIT 지점/변경 전/특정 SAVEPOINT 지점으로 원복됨

**SAVEPOINT**

전체 작업을 되돌리지 않고 일부만 되돌릴 수 있게 함

### DDL

Data Definition Language

데이터 구조 정의(객체 생성, 삭제, 변경 언어)

AUTO COMMIT!! (명령어 수행하면 즉시 저장)-ORACLE 한정, SQL SERVER는 안됨!

**CREATE**

테이블 생성

테이블명, 컬럼명, 컬럼순서, 컬럼크기, 컬럼 데이터타입 정의 필수!!

컬럼의 제약조건 및 기본값은 생략 가능

- 문법) 테이블 생성

CREATE TABLE [소유자.] 테이블명(
      컬럼 1 데이터타입[DEFAULT 기본값] [제약조건],
      컬럼 2 데이터타입[DEFAULT 기본값] [제약조건],
       ….
);

- 문법) 테이블 복제

CREATE TABLE 테이블명

AS

SELECT * FROM 복제테이블명;

→ 테이블에 있는 제약조건, INDEX 등은 복제 X
     항상 거짓인 조건을 WHERE절에 전달하면 테이블 구조만 복제 가능

제약조건(CONSTRAINT)

문법) ALTER TABLE 테이블명 ADD CONTRAINT 제약조건명 제약조건 (컬럼명);

- PRIMARY KEY : 중복허용X, NULL 허용X
- UNIQUE KEY : 중복허용X, NULL 허용O
- NOT NULL : NULL 허용 X
→ 이미 만들어진 컬럼에 NOT NULL 선언 시 제약조건 생성이 아닌 컬럼수정(MODIFY)로 해결
- CHECK : 컬럼에 저장될 수 있는 범위 제한
- FOREIGN KEY : 반드시 참조(부모)테이블의 참조컬럼(REFERENCE KEY)이 사전에 PK 혹은 UNIQUE KEY를 가져야 함
    
    FK 옵션
    
    - ON DELETE CASCADE : 부모 데이터 삭제 시 자식 데이터도 함께 삭제
    - ON DELETE SET NULL : 부모 데이터 삭제 시 자식 데이터의 참조 값은 NULL로 수정

데이터타입

- CHAR(n) : 고정형 문자 타입으로 문자 전달 필수
                    사이즈만큼 확정형 데이터가 입력(빈자리수는 공백으로 채워짐)
- VARCHAR(n) : 가변형 문자 타입으로 사이즈 전달 필수
                           사이즈보다 작은 문자값이 입력되더라도 입력값 그대로 유지
- NUMBER(p, s) : 숫자형 타입으로 자릿수 생략 가능, 소수점 자리 제한 시 s 전달
                             p는 총 자리수
- DATE

**ALTER**

컬럼 순서는 변경 불가, 항상 맨 뒤에 추가됨

- ADD COLUMN : 새로운 컬럼 추가
- DROP COLUMN : 컬럼 삭제
- MODIFY COLUMN : 컬럼 변경
→ 데이터 유형, DEFAULT 값, NOT NULL 제약조건에 대한 변경 가능
컬럼에 저장된 모든 데이터의 크기가 줄이고자 하는 컬럼의 크기보다 작을 경우에만 줄일 수 있음
크기를 늘리는 것은 무조건 가능
컬럼의 저장된 데이터가 없는 경우에만 데이터 유형 변경 가능
DEFAULT 값 변경 시에는 변경 이후 저장되는 데이터에만 적용
현재 NULL 값이 저장되어 있지 않은 컬럼에만 NOT NULL 제약 조건 추가 가능
- RENAME COLUMN
- ADD CONSTRAINT

**DROP** 

테이블을 삭제할 때 사용
CASCADE 옵션 (자식 테이블에 주기)

- CASCADE CONSTRAINT : 참조 제약조건도 함께 삭제
- PURGE : PURGE로 테이블 삭제 시 RECYCLEBIN 에서 조회 불가

**RENAME**

테이블명 변경

**TRUNCATE**

테이블에 저장되어 있는 데이터를 모두 삭제

구조 남기고 데이터만 즉시 삭제, AUTOCOMMIT!!

DELETE/DROP/TRUNCATE 비교

- DELETE : 데이터 일부 혹은 전체 삭제, 롤백 가능
- DROP : 데이터와 구조를 동시 삭제, 즉시반영(롤백 불가)
- TRUNCATE: 데이터 전체삭제만 가능(일부삭제 불가), 즉시반영(롤백 불가)

### DCL

Data Control Language

USER를 생성하고 데이터를 컨트롤할 수 있는 권한을 부여하거나 회수하는 방법

**GRANT**

사용자에게 권한을 부여하는 명령어

- 오브젝트 권한 : 테이블에 대한 권한 제어
- 시스템 권한 :시스템 작업 등을 제어

동시에 여러 유저 권한 부여 가능

동시 여러 권한 부여 가능

동시 여러 객체 권한 부여 불가

권한 부여 옵션(중간관리자 권한)

- WITH GRANT OPTION
→ 오브젝트 권한을 다른 사용자에게 부여
     중간관리자만 회수 가능
     중간관리자 권한 회수 시 제 3자에게 부여된 권한도 같이 회수
- WITH ADMIN OPTION
→ 시스템 권한/롤 권한을 다른 사용자에게 부여
     중간관리자 안 거치고 직접 회수 가능
     중간관리자 권한 회수 시 제 3자 권한은 남아있음

**REVOKE**

사용자에게 권한을 회수하는 명령어

동시 여러 권한 회수 가능

동시 여러 유저로부터 권한 회수 가능

이미 회수한 권한 재 회수 불가

**ROLE 관련 명령어**

ROLE 이란 특정 권한들을 하나의 세트처럼 묶음

1. ROLE 을 생성
ex) CREATE ROLE CREATE_R;
2. ROLE에 권한 부여
ex) GRANT CREATE SESSION, CREATE USER, CREATE TABLE TO CREATE_R;
3. ROLE을 사용자에게 부여
ex) GRANT CREATE_R TO YEJUN;